{"version":3,"sources":["webpack:///267e525a74f96ba570e8.worker.js","webpack:///webpack/bootstrap 267e525a74f96ba570e8","webpack:///./src/parse.js","webpack:///./~/papaparse/papaparse.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_papaparse","_papaparse2","nthIndex","str","pat","n","L","length","i","indexOf","onmessage","e","messages","parse","data","value","newline","step","results","strings","dateEnd","nameEnd","date","substring","name","message","push","complete","postMessage","type","worker","skipEmptyLines","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","undefined","this","CsvToJson","_input","_config","dynamicTyping","Papa","WORKERS_SUPPORTED","w","newWorker","userStep","userChunk","chunk","userComplete","userError","error","isFunction","input","config","workerId","streamer","download","NetworkStreamer","StringStreamer","readable","read","on","ReadableStreamStreamer","global","File","Object","FileStreamer","stream","JsonToCsv","unpackConfig","delimiter","BAD_DELIMITERS","_delimiter","quotes","Array","_quotes","_newline","quoteChar","_quoteChar","header","_writeHeader","objectKeys","keys","key","serialize","fields","csv","JSON","hasHeader","dataKeyedByField","safe","row","maxCol","col","colIdx","toString","replace","quoteCharRegex","needsQuotes","hasAny","charAt","substrings","RegExp","meta","ChunkStreamer","replaceConfig","configCopy","copy","chunkSize","parseInt","_handle","ParserHandle","_paused","_finished","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","parseChunk","beforeFirstChunk","modifiedChunk","aggregate","paused","aborted","lastIndex","cursor","finishedIncludingPreview","preview","IS_PAPA_WORKER","WORKER_ID","finished","concat","_sendError","getFileSize","xhr","contentRange","getResponseHeader","substr","lastIndexOf","RemoteChunkSize","IS_WORKER","_readChunk","_chunkLoaded","url","XMLHttpRequest","withCredentials","onload","bindFunction","onerror","_chunkError","open","end","setRequestHeader","send","err","status","readyState","responseText","errorMessage","errorText","statusText","LocalChunkSize","reader","slice","usingAsyncReader","FileReader","file","webkitSlice","mozSlice","FileReaderSync","Math","min","size","txt","readAsText","encoding","target","result","event","string","remaining","s","queue","parseOnData","_streamData","_streamEnd","_streamError","shift","_streamCleanUp","removeListener","processResults","_results","_delimiterError","addError","DefaultDelimiter","splice","needsHeaderRow","fillHeaderFields","applyHeaderAndDynamicTyping","_fields","j","parseDynamic","field","tryParseFloat","guessDelimiter","bestDelim","bestDelta","fieldCountPrevRow","delimChoices","RECORD_SEP","UNIT_SEP","delim","delta","avgFieldCount","Parser","fieldCount","abs","successful","bestDelimiter","guessLineEndings","r","split","nAppearsFirst","numWithN","val","isNumber","FLOAT","test","parseFloat","code","msg","_parser","self","_stepCounter","_aborted","abort","baseIndex","ignoreLastRow","delimGuess","parserConfig","pause","getCharIndex","resume","comments","fastMode","pushRow","lastCursor","finish","returnable","inputLen","stepIsFunction","doStep","saveRow","newCursor","nextNewline","stopped","linebreak","truncated","delimLen","newlineLen","commentsLen","rows","nextDelim","quoteSearch","index","getScriptPath","scripts","document","getElementsByTagName","src","LOADED_SYNC","SCRIPT_PATH","Error","workerUrl","AUTO_SCRIPT_PATH","Worker","mainThreadReceivedMessage","workerIdCounter","workers","completeWorker","handle","notImplemented","terminate","workerThreadReceivedMessage","cpy","f","arguments","func","window","location","search","unparse","String","fromCharCode","BYTE_ORDER_MARK","jQuery","$","fn","options","parseNextFile","before","returned","inputElem","action","reason","fileComplete","instanceConfig","extend","userCompleteFunc","elem","each","idx","supported","prop","toUpperCase","attr","toLowerCase","files","body","addEventListener","prototype","create","constructor"],"mappings":"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","file":"267e525a74f96ba570e8.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/honeybuns/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _papaparse = __webpack_require__(1);\n\t\n\tvar _papaparse2 = _interopRequireDefault(_papaparse);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar nthIndex = function nthIndex(str, pat, n) {\n\t    var L = str.length;\n\t    var i = -1;\n\t    while (n-- && i++ < L) {\n\t        i = str.indexOf(pat, i);\n\t        if (i < 0) break;\n\t    }\n\t    return i;\n\t};\n\t\n\tonmessage = function onmessage(e) {\n\t    // eslint-disable-line no-undef\n\t    var messages = [];\n\t    _papaparse2.default.parse(e.data.value, {\n\t        newline: '\\r\\n',\n\t        step: function step(results) {\n\t            // Example of results returned in an array\n\t            // 0: \"2017-03-12\"\n\t            // 1: \" 9:59:47 AM: Ana Lala: Dude\"\n\t            var strings = results.data[0];\n\t            if (strings.length === 1) {\n\t                return; // find a way to handle message that wraps but does a new line first\n\t            }\n\t            var dateEnd = nthIndex(strings[1], \":\", 3);\n\t            var nameEnd = nthIndex(strings[1], \":\", 4);\n\t            if (nameEnd === -1) {\n\t                // Auto-message: Messages you send to this chat and calls are now secured with end-to-end encryption.\n\t                return;\n\t            }\n\t            // 2017-01-09, 12:41:06 PM\n\t            var date = strings[0] + strings[1].substring(0, dateEnd);\n\t            var name = strings[1].substring(dateEnd + 2, nameEnd);\n\t            var message = strings[1].substring(nameEnd + 2, strings[1].length);\n\t            var m = {\n\t                date: date,\n\t                name: name,\n\t                message: message\n\t            };\n\t            messages.push(m);\n\t        },\n\t        complete: function complete() {\n\t            postMessage({ type: \"done\", value: messages });\n\t        },\n\t        worker: true,\n\t        skipEmptyLines: true\n\t    });\n\t};\n\t//\n\t// const Parse = (file) => {\n\t//     let messages = [];\n\t//     Papa.parse(file, {\n\t//         newline: '\\r\\n',\n\t//         step: (results) => {\n\t//             // Example of results returned in an array\n\t//             // 0: \"2017-03-12\"\n\t//             // 1: \" 9:59:47 AM: Ana Lala: Dude\"\n\t//             let strings = results.data[0];\n\t//             if (strings.length === 1) {\n\t//                 return; // find a way to handle message that wraps but does a new line first\n\t//             }\n\t//             let dateEnd = nthIndex(strings[1], \":\", 3);\n\t//             let nameEnd = nthIndex(strings[1], \":\", 4);\n\t//             if (nameEnd === -1) { // Auto-message: Messages you send to this chat and calls are now secured with end-to-end encryption.\n\t//                 return;\n\t//             }\n\t//             // 2017-01-09, 12:41:06 PM\n\t//             let date = strings[0] + strings[1].substring(0, dateEnd);\n\t//             let name = strings[1].substring(dateEnd + 2, nameEnd);\n\t//             let message = strings[1].substring(nameEnd + 2, strings[1].length);\n\t//             let m = new Message(date, name, message);\n\t//             messages.push(m);\n\t//         },\n\t//         complete: () => {\n\t//             return messages;\n\t//         },\n\t//         worker: true,\n\t//         skipEmptyLines: true\n\t//     });\n\t// };\n\t//\n\t// export default Parse;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t\tPapa Parse\n\t\tv4.2.0\n\t\thttps://github.com/mholt/PapaParse\n\t*/\n\t(function(root, factory)\n\t{\n\t\tif (true)\n\t\t{\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\n\t\telse if (typeof module === 'object' && module.exports)\n\t\t{\n\t\t\t// Node. Does not work with strict CommonJS, but\n\t\t\t// only CommonJS-like environments that support module.exports,\n\t\t\t// like Node.\n\t\t\tmodule.exports = factory();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Browser globals (root is window)\n\t\t\troot.Papa = factory();\n\t\t}\n\t}(this, function()\n\t{\n\t\t'use strict';\n\t\n\t\tvar global = (function () {\n\t\t\t// alternative method, similar to `Function('return this')()`\n\t\t\t// but without using `eval` (which is disabled when\n\t\t\t// using Content Security Policy).\n\t\n\t\t\tif (typeof self !== 'undefined') { return self; }\n\t\t\tif (typeof window !== 'undefined') { return window; }\n\t\t\tif (typeof global !== 'undefined') { return global; }\n\t\n\t        // When running tests none of the above have been defined\n\t        return {};\n\t\t})();\n\t\n\t\n\t\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\t\tvar workers = {}, workerIdCounter = 0;\n\t\n\t\tvar Papa = {};\n\t\n\t\tPapa.parse = CsvToJson;\n\t\tPapa.unparse = JsonToCsv;\n\t\n\t\tPapa.RECORD_SEP = String.fromCharCode(30);\n\t\tPapa.UNIT_SEP = String.fromCharCode(31);\n\t\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\t\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\t\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\t\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\t\n\t\t// Configurable chunk sizes for local and remote files, respectively\n\t\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\t\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\t\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\t\n\t\t// Exposed for testing and development only\n\t\tPapa.Parser = Parser;\n\t\tPapa.ParserHandle = ParserHandle;\n\t\tPapa.NetworkStreamer = NetworkStreamer;\n\t\tPapa.FileStreamer = FileStreamer;\n\t\tPapa.StringStreamer = StringStreamer;\n\t\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\t\n\t\tif (global.jQuery)\n\t\t{\n\t\t\tvar $ = global.jQuery;\n\t\t\t$.fn.parse = function(options)\n\t\t\t{\n\t\t\t\tvar config = options.config || {};\n\t\t\t\tvar queue = [];\n\t\n\t\t\t\tthis.each(function(idx)\n\t\t\t\t{\n\t\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t\t&& global.FileReader;\n\t\n\t\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\t\treturn true;\t// continue to next input element\n\t\n\t\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tparseNextFile();\t// begin parsing\n\t\t\t\treturn this;\t\t// maintains chainability\n\t\n\t\n\t\t\t\tfunction parseNextFile()\n\t\t\t\t{\n\t\t\t\t\tif (queue.length === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\t\toptions.complete();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar f = queue[0];\n\t\n\t\t\t\t\tif (isFunction(options.before))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\t\n\t\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\t\tfileComplete();\n\t\t\t\t\t};\n\t\n\t\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t\t}\n\t\n\t\t\t\tfunction error(name, file, elem, reason)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t\t}\n\t\n\t\t\t\tfunction fileComplete()\n\t\t\t\t{\n\t\t\t\t\tqueue.splice(0, 1);\n\t\t\t\t\tparseNextFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tif (IS_PAPA_WORKER)\n\t\t{\n\t\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t\t}\n\t\telse if (Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\t\n\t\t\t// Check if the script was loaded synchronously\n\t\t\tif (!document.body)\n\t\t\t{\n\t\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\t\tLOADED_SYNC = true;\n\t\t\t\t}, true);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\tfunction CsvToJson(_input, _config)\n\t\t{\n\t\t\t_config = _config || {};\n\t\t\t_config.dynamicTyping = _config.dynamicTyping || false;\n\t\n\t\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t\t{\n\t\t\t\tvar w = newWorker();\n\t\n\t\t\t\tw.userStep = _config.step;\n\t\t\t\tw.userChunk = _config.chunk;\n\t\t\t\tw.userComplete = _config.complete;\n\t\t\t\tw.userError = _config.error;\n\t\n\t\t\t\t_config.step = isFunction(_config.step);\n\t\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t\t_config.error = isFunction(_config.error);\n\t\t\t\tdelete _config.worker;\t// prevent infinite loop\n\t\n\t\t\t\tw.postMessage({\n\t\t\t\t\tinput: _input,\n\t\t\t\t\tconfig: _config,\n\t\t\t\t\tworkerId: w.id\n\t\t\t\t});\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar streamer = null;\n\t\t\tif (typeof _input === 'string')\n\t\t\t{\n\t\t\t\tif (_config.download)\n\t\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\t\telse\n\t\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t\t}\n\t\t\telse if (_input.readable === true && typeof _input.read === 'function' && typeof _input.on === 'function')\n\t\t\t{\n\t\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t\t}\n\t\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\t\tstreamer = new FileStreamer(_config);\n\t\n\t\t\treturn streamer.stream(_input);\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tfunction JsonToCsv(_input, _config)\n\t\t{\n\t\t\tvar _output = '';\n\t\t\tvar _fields = [];\n\t\n\t\t\t// Default configuration\n\t\n\t\t\t/** whether to surround every datum with quotes */\n\t\t\tvar _quotes = false;\n\t\n\t\t\t/** whether to write headers */\n\t\t\tvar _writeHeader = true;\n\t\n\t\t\t/** delimiting character */\n\t\t\tvar _delimiter = ',';\n\t\n\t\t\t/** newline character(s) */\n\t\t\tvar _newline = '\\r\\n';\n\t\n\t\t\t/** quote character */\n\t\t\tvar _quoteChar = '\"';\n\t\n\t\t\tunpackConfig();\n\t\n\t\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\t\n\t\t\tif (typeof _input === 'string')\n\t\t\t\t_input = JSON.parse(_input);\n\t\n\t\t\tif (_input instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\t\treturn serialize(null, _input);\n\t\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t\t}\n\t\t\telse if (typeof _input === 'object')\n\t\t\t{\n\t\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t\t_input.data = JSON.parse(_input.data);\n\t\n\t\t\t\tif (_input.data instanceof Array)\n\t\t\t\t{\n\t\t\t\t\tif (!_input.fields)\n\t\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\t\n\t\t\t\t\tif (!_input.fields)\n\t\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\t\n\t\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t\t}\n\t\n\t\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t\t}\n\t\n\t\t\t// Default (any valid paths should return before this)\n\t\t\tthrow 'exception: Unable to serialize unrecognized input';\n\t\n\t\n\t\t\tfunction unpackConfig()\n\t\t\t{\n\t\t\t\tif (typeof _config !== 'object')\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t\t{\n\t\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t\t_quotes = _config.quotes;\n\t\n\t\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t\t_newline = _config.newline;\n\t\n\t\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t\t_quoteChar = _config.quoteChar;\n\t\n\t\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t\t_writeHeader = _config.header;\n\t\t\t}\n\t\n\t\n\t\t\t/** Turns an object's keys into an array */\n\t\t\tfunction objectKeys(obj)\n\t\t\t{\n\t\t\t\tif (typeof obj !== 'object')\n\t\t\t\t\treturn [];\n\t\t\t\tvar keys = [];\n\t\t\t\tfor (var key in obj)\n\t\t\t\t\tkeys.push(key);\n\t\t\t\treturn keys;\n\t\t\t}\n\t\n\t\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\t\tfunction serialize(fields, data)\n\t\t\t{\n\t\t\t\tvar csv = '';\n\t\n\t\t\t\tif (typeof fields === 'string')\n\t\t\t\t\tfields = JSON.parse(fields);\n\t\t\t\tif (typeof data === 'string')\n\t\t\t\t\tdata = JSON.parse(data);\n\t\n\t\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\t\n\t\t\t\t// If there a header row, write it first\n\t\t\t\tif (hasHeader && _writeHeader)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t\t}\n\t\t\t\t\tif (data.length > 0)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\t// Then write out the data\n\t\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t\t{\n\t\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\t\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\treturn csv;\n\t\t\t}\n\t\n\t\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\t\tfunction safe(str, col)\n\t\t\t{\n\t\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\t\treturn '';\n\t\n\t\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);\n\t\n\t\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\t\n\t\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t\t}\n\t\n\t\t\tfunction hasAny(str, substrings)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\t\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\t\tfunction ChunkStreamer(config)\n\t\t{\n\t\t\tthis._handle = null;\n\t\t\tthis._paused = false;\n\t\t\tthis._finished = false;\n\t\t\tthis._input = null;\n\t\t\tthis._baseIndex = 0;\n\t\t\tthis._partialLine = '';\n\t\t\tthis._rowCount = 0;\n\t\t\tthis._start = 0;\n\t\t\tthis._nextChunk = null;\n\t\t\tthis.isFirstChunk = true;\n\t\t\tthis._completeResults = {\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\t\treplaceConfig.call(this, config);\n\t\n\t\t\tthis.parseChunk = function(chunk)\n\t\t\t{\n\t\t\t\t// First chunk pre-processing\n\t\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t\t{\n\t\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t\t}\n\t\t\t\tthis.isFirstChunk = false;\n\t\n\t\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\t\tthis._partialLine = '';\n\t\n\t\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\t\n\t\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\t\treturn;\n\t\n\t\t\t\tvar lastIndex = results.meta.cursor;\n\t\n\t\t\t\tif (!this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t\t}\n\t\n\t\t\t\tif (results && results.data)\n\t\t\t\t\tthis._rowCount += results.data.length;\n\t\n\t\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\t\n\t\t\t\tif (IS_PAPA_WORKER)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t\t{\n\t\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\t\tif (this._paused)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tresults = undefined;\n\t\t\t\t\tthis._completeResults = undefined;\n\t\t\t\t}\n\t\n\t\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t\t}\n\t\n\t\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\n\t\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\t\tthis._nextChunk();\n\t\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t\tthis._sendError = function(error)\n\t\t\t{\n\t\t\t\tif (isFunction(this._config.error))\n\t\t\t\t\tthis._config.error(error);\n\t\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tfinished: false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction replaceConfig(config)\n\t\t\t{\n\t\t\t\t// Deep-copy the config so we can edit it\n\t\t\t\tvar configCopy = copy(config);\n\t\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\t\tif (!config.step && !config.chunk)\n\t\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\t\tthis._handle.streamer = this;\n\t\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfunction NetworkStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar xhr;\n\t\n\t\t\tif (IS_WORKER)\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tthis.stream = function(url)\n\t\t\t{\n\t\t\t\tthis._input = url;\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\txhr = new XMLHttpRequest();\n\t\n\t\t\t\tif (this._config.withCredentials)\n\t\t\t\t{\n\t\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t\t}\n\t\n\t\t\t\tif (!IS_WORKER)\n\t\t\t\t{\n\t\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\n\t\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\t\txhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);\n\t\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\txhr.send();\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tthis._chunkError(err.message);\n\t\t\t\t}\n\t\n\t\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\t\tthis._chunkError();\n\t\t\t\telse\n\t\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function()\n\t\t\t{\n\t\t\t\tif (xhr.readyState != 4)\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkError();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\t\tthis.parseChunk(xhr.responseText);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function(errorMessage)\n\t\t\t{\n\t\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\t\tthis._sendError(errorText);\n\t\t\t}\n\t\n\t\t\tfunction getFileSize(xhr)\n\t\t\t{\n\t\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\t\tif (contentRange === null) { // no content range, then finish!\n\t        \t\t\treturn -1;\n\t            \t\t}\n\t\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t\t}\n\t\t}\n\t\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\t\n\t\n\t\tfunction FileStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar reader, slice;\n\t\n\t\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\t\n\t\t\tthis.stream = function(file)\n\t\t\t{\n\t\t\t\tthis._input = file;\n\t\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\t\n\t\t\t\tif (usingAsyncReader)\n\t\t\t\t{\n\t\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\t\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\t\tthis._readChunk();\n\t\t\t}\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tvar input = this._input;\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t\t}\n\t\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\t\tif (!usingAsyncReader)\n\t\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function(event)\n\t\t\t{\n\t\t\t\t// Very important to increment start each time before handling results\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\t\tthis.parseChunk(event.target.result);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function()\n\t\t\t{\n\t\t\t\tthis._sendError(reader.error);\n\t\t\t}\n\t\n\t\t}\n\t\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tFileStreamer.prototype.constructor = FileStreamer;\n\t\n\t\n\t\tfunction StringStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar string;\n\t\t\tvar remaining;\n\t\t\tthis.stream = function(s)\n\t\t\t{\n\t\t\t\tstring = s;\n\t\t\t\tremaining = s;\n\t\t\t\treturn this._nextChunk();\n\t\t\t}\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished) return;\n\t\t\t\tvar size = this._config.chunkSize;\n\t\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\t\tthis._finished = !remaining;\n\t\t\t\treturn this.parseChunk(chunk);\n\t\t\t}\n\t\t}\n\t\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\t\tStringStreamer.prototype.constructor = StringStreamer;\n\t\n\t\n\t\tfunction ReadableStreamStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar queue = [];\n\t\t\tvar parseOnData = true;\n\t\n\t\t\tthis.stream = function(stream)\n\t\t\t{\n\t\t\t\tthis._input = stream;\n\t\n\t\t\t\tthis._input.on('data', this._streamData);\n\t\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\t\tthis._input.on('error', this._streamError);\n\t\t\t}\n\t\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (queue.length)\n\t\t\t\t{\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparseOnData = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis._streamData = bindFunction(function(chunk)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\t\n\t\t\t\t\tif (parseOnData)\n\t\t\t\t\t{\n\t\t\t\t\t\tparseOnData = false;\n\t\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t\tthis._streamError(error);\n\t\t\t\t}\n\t\t\t}, this);\n\t\n\t\t\tthis._streamError = bindFunction(function(error)\n\t\t\t{\n\t\t\t\tthis._streamCleanUp();\n\t\t\t\tthis._sendError(error.message);\n\t\t\t}, this);\n\t\n\t\t\tthis._streamEnd = bindFunction(function()\n\t\t\t{\n\t\t\t\tthis._streamCleanUp();\n\t\t\t\tthis._finished = true;\n\t\t\t\tthis._streamData('');\n\t\t\t}, this);\n\t\n\t\t\tthis._streamCleanUp = bindFunction(function()\n\t\t\t{\n\t\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t\t}, this);\n\t\t}\n\t\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\t\n\t\n\t\t// Use one ParserHandle per entire CSV file or string\n\t\tfunction ParserHandle(_config)\n\t\t{\n\t\t\t// One goal is to minimize the use of regular expressions...\n\t\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\t\n\t\t\tvar self = this;\n\t\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\t\tvar _input;\t\t\t\t// The input being parsed\n\t\t\tvar _parser;\t\t\t// The core parser being used\n\t\t\tvar _paused = false;\t// Whether we are paused or not\n\t\t\tvar _aborted = false;   // Whether the parser has aborted or not\n\t\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\n\t\t\tif (isFunction(_config.step))\n\t\t\t{\n\t\t\t\tvar userStep = _config.step;\n\t\t\t\t_config.step = function(results)\n\t\t\t\t{\n\t\t\t\t\t_results = results;\n\t\n\t\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\t\tprocessResults();\n\t\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t\t{\n\t\t\t\t\t\tprocessResults();\n\t\n\t\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t\t * when an input comes in multiple chunks, like from a file.\n\t\t\t */\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\tif (!_config.newline)\n\t\t\t\t\t_config.newline = guessLineEndings(input);\n\t\n\t\t\t\t_delimiterError = false;\n\t\t\t\tif (!_config.delimiter)\n\t\t\t\t{\n\t\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline);\n\t\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t\t}\n\t\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t\t}\n\t\t\t\telse if(typeof _config.delimiter === 'function')\n\t\t\t\t{\n\t\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tvar parserConfig = copy(_config);\n\t\t\t\tif (_config.preview && _config.header)\n\t\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\t\n\t\t\t\t_input = input;\n\t\t\t\t_parser = new Parser(parserConfig);\n\t\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\t\tprocessResults();\n\t\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t\t};\n\t\n\t\t\tthis.paused = function()\n\t\t\t{\n\t\t\t\treturn _paused;\n\t\t\t};\n\t\n\t\t\tthis.pause = function()\n\t\t\t{\n\t\t\t\t_paused = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t\t};\n\t\n\t\t\tthis.resume = function()\n\t\t\t{\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input);\n\t\t\t};\n\t\n\t\t\tthis.aborted = function ()\n\t\t\t{\n\t\t\t\treturn _aborted;\n\t\t\t};\n\t\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\t_aborted = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_results.meta.aborted = true;\n\t\t\t\tif (isFunction(_config.complete))\n\t\t\t\t\t_config.complete(_results);\n\t\t\t\t_input = '';\n\t\t\t};\n\t\n\t\t\tfunction processResults()\n\t\t\t{\n\t\t\t\tif (_results && _delimiterError)\n\t\t\t\t{\n\t\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\''+Papa.DefaultDelimiter+'\\'');\n\t\t\t\t\t_delimiterError = false;\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.skipEmptyLines)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t\t}\n\t\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tfillHeaderFields();\n\t\n\t\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t\t}\n\t\n\t\t\tfunction needsHeaderRow()\n\t\t\t{\n\t\t\t\treturn _config.header && _fields.length === 0;\n\t\t\t}\n\t\n\t\t\tfunction fillHeaderFields()\n\t\t\t{\n\t\t\t\tif (!_results)\n\t\t\t\t\treturn;\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\n\t\t\tfunction parseDynamic(field, value)\n\t\t\t{\n\t\t\t\tif ((_config.dynamicTyping[field] || _config.dynamicTyping) === true)\n\t\t\t\t{\n\t\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\t\treturn false;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn tryParseFloat(value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tfunction applyHeaderAndDynamicTyping()\n\t\t\t{\n\t\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\t\treturn _results;\n\t\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = _config.header ? {} : [];\n\t\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar field = j;\n\t\t\t\t\t\tvar value = _results.data[i][j];\n\t\n\t\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\t\n\t\t\t\t\t\tvalue = parseDynamic(field, value);\n\t\n\t\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trow[field] = value;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_results.data[i] = row;\n\t\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.header && _results.meta)\n\t\t\t\t\t_results.meta.fields = _fields;\n\t\t\t\treturn _results;\n\t\t\t}\n\t\n\t\t\tfunction guessDelimiter(input, newline)\n\t\t\t{\n\t\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\t\n\t\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\t\tvar delta = 0, avgFieldCount = 0;\n\t\t\t\t\tfieldCountPrevRow = undefined;\n\t\n\t\t\t\t\tvar preview = new Parser({\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tnewline: newline,\n\t\t\t\t\t\tpreview: 10\n\t\t\t\t\t}).parse(input);\n\t\n\t\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\t\tavgFieldCount += fieldCount;\n\t\n\t\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\t\tavgFieldCount /= preview.data.length;\n\t\n\t\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t_config.delimiter = bestDelim;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\t\tbestDelimiter: bestDelim\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction guessLineEndings(input)\n\t\t\t{\n\t\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\t\n\t\t\t\tvar r = input.split('\\r');\n\t\n\t\t\t\tvar n = input.split('\\n');\n\t\n\t\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\t\n\t\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\t\treturn '\\n';\n\t\n\t\t\t\tvar numWithN = 0;\n\t\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\t\tnumWithN++;\n\t\t\t\t}\n\t\n\t\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t\t}\n\t\n\t\t\tfunction tryParseFloat(val)\n\t\t\t{\n\t\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t\t}\n\t\n\t\t\tfunction addError(type, code, msg, row)\n\t\t\t{\n\t\t\t\t_results.errors.push({\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcode: code,\n\t\t\t\t\tmessage: msg,\n\t\t\t\t\trow: row\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\t/** The core parser implements speedy and correct CSV parsing */\n\t\tfunction Parser(config)\n\t\t{\n\t\t\t// Unpack the config object\n\t\t\tconfig = config || {};\n\t\t\tvar delim = config.delimiter;\n\t\t\tvar newline = config.newline;\n\t\t\tvar comments = config.comments;\n\t\t\tvar step = config.step;\n\t\t\tvar preview = config.preview;\n\t\t\tvar fastMode = config.fastMode;\n\t\t\tvar quoteChar = config.quoteChar || '\"';\n\t\n\t\t\t// Delimiter must be valid\n\t\t\tif (typeof delim !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\t\tdelim = ',';\n\t\n\t\t\t// Comment character must be valid\n\t\t\tif (comments === delim)\n\t\t\t\tthrow 'Comment character same as delimiter';\n\t\t\telse if (comments === true)\n\t\t\t\tcomments = '#';\n\t\t\telse if (typeof comments !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\t\tcomments = false;\n\t\n\t\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\t\tnewline = '\\n';\n\t\n\t\t\t// We're gonna need these at the Parser scope\n\t\t\tvar cursor = 0;\n\t\t\tvar aborted = false;\n\t\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\t\tif (typeof input !== 'string')\n\t\t\t\t\tthrow 'Input must be a string';\n\t\n\t\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t\t// but having them in a more local scope seems to perform better\n\t\t\t\tvar inputLen = input.length,\n\t\t\t\t\tdelimLen = delim.length,\n\t\t\t\t\tnewlineLen = newline.length,\n\t\t\t\t\tcommentsLen = comments.length;\n\t\t\t\tvar stepIsFunction = typeof step === 'function';\n\t\n\t\t\t\t// Establish starting state\n\t\t\t\tcursor = 0;\n\t\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\t\n\t\t\t\tif (!input)\n\t\t\t\t\treturn returnable();\n\t\n\t\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t\t{\n\t\t\t\t\tvar rows = input.split(newline);\n\t\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\t\tcursor += row.length;\n\t\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\t\tvar quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');\n\t\n\t\t\t\t// Parser loop\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\t// Field has opening quote\n\t\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\t\tvar quoteSearch = cursor;\n\t\n\t\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\t\tcursor++;\n\t\n\t\t\t\t\t\tfor (;;)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\t\tvar quoteSearch = input.indexOf(quoteChar, quoteSearch+1);\n\t\n\t\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t\tif (input[quoteSearch+1] === quoteChar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (input[quoteSearch+1] === delim)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\n\t\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Comment found at start of new line\n\t\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// End of row\n\t\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\t\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\n\t\t\t\treturn finish();\n\t\n\t\n\t\t\t\tfunction pushRow(row)\n\t\t\t\t{\n\t\t\t\t\tdata.push(row);\n\t\t\t\t\tlastCursor = cursor;\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t\t */\n\t\t\t\tfunction finish(value)\n\t\t\t\t{\n\t\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\t\trow.push(value);\n\t\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t\t * take care to execute user's step function and check for\n\t\t\t\t * preview and end parsing if necessary.\n\t\t\t\t */\n\t\t\t\tfunction saveRow(newCursor)\n\t\t\t\t{\n\t\t\t\t\tcursor = newCursor;\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\trow = [];\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t}\n\t\n\t\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\t\tfunction returnable(stopped)\n\t\t\t\t{\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\terrors: errors,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\t\tfunction doStep()\n\t\t\t\t{\n\t\t\t\t\tstep(returnable());\n\t\t\t\t\tdata = [], errors = [];\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/** Sets the abort flag */\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\taborted = true;\n\t\t\t};\n\t\n\t\t\t/** Gets the cursor position */\n\t\t\tthis.getCharIndex = function()\n\t\t\t{\n\t\t\t\treturn cursor;\n\t\t\t};\n\t\t}\n\t\n\t\n\t\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\t\tfunction getScriptPath()\n\t\t{\n\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t\t}\n\t\n\t\tfunction newWorker()\n\t\t{\n\t\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\t\treturn false;\n\t\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t\t);\n\t\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\t\tvar w = new global.Worker(workerUrl);\n\t\t\tw.onmessage = mainThreadReceivedMessage;\n\t\t\tw.id = workerIdCounter++;\n\t\t\tworkers[w.id] = w;\n\t\t\treturn w;\n\t\t}\n\t\n\t\t/** Callback when main thread receives a message */\n\t\tfunction mainThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\t\tvar worker = workers[msg.workerId];\n\t\t\tvar aborted = false;\n\t\n\t\t\tif (msg.error)\n\t\t\t\tworker.userError(msg.error, msg.file);\n\t\t\telse if (msg.results && msg.results.data)\n\t\t\t{\n\t\t\t\tvar abort = function() {\n\t\t\t\t\taborted = true;\n\t\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t\t};\n\t\n\t\t\t\tvar handle = {\n\t\t\t\t\tabort: abort,\n\t\t\t\t\tpause: notImplemented,\n\t\t\t\t\tresume: notImplemented\n\t\t\t\t};\n\t\n\t\t\t\tif (isFunction(worker.userStep))\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t\t}, handle);\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t\t}\n\t\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t\t{\n\t\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\t\tdelete msg.results;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (msg.finished && !aborted)\n\t\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t\t}\n\t\n\t\tfunction completeWorker(workerId, results) {\n\t\t\tvar worker = workers[workerId];\n\t\t\tif (isFunction(worker.userComplete))\n\t\t\t\tworker.userComplete(results);\n\t\t\tworker.terminate();\n\t\t\tdelete workers[workerId];\n\t\t}\n\t\n\t\tfunction notImplemented() {\n\t\t\tthrow 'Not implemented.';\n\t\t}\n\t\n\t\t/** Callback when worker thread receives a message */\n\t\tfunction workerThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\n\t\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\t\tPapa.WORKER_ID = msg.workerId;\n\t\n\t\t\tif (typeof msg.input === 'string')\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t\t{\n\t\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\t\tif (results)\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tfinished: true\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\t/** Makes a deep copy of an array or object (mostly) */\n\t\tfunction copy(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn obj;\n\t\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\t\tfor (var key in obj)\n\t\t\t\tcpy[key] = copy(obj[key]);\n\t\t\treturn cpy;\n\t\t}\n\t\n\t\tfunction bindFunction(f, self)\n\t\t{\n\t\t\treturn function() { f.apply(self, arguments); };\n\t\t}\n\t\n\t\tfunction isFunction(func)\n\t\t{\n\t\t\treturn typeof func === 'function';\n\t\t}\n\t\n\t\treturn Papa;\n\t}));\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 267e525a74f96ba570e8.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/honeybuns/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 267e525a74f96ba570e8","import Papa from 'papaparse';\n\nlet nthIndex = (str, pat, n) => {\n    let L= str.length;\n    let i= -1;\n    while(n-- && i++<L){\n        i = str.indexOf(pat, i);\n        if (i < 0) break;\n    }\n    return i;\n};\n\nonmessage = (e) => { // eslint-disable-line no-undef\n    let messages = [];\n    Papa.parse(e.data.value, {\n        newline: '\\r\\n',\n        step: (results) => {\n            // Example of results returned in an array\n            // 0: \"2017-03-12\"\n            // 1: \" 9:59:47 AM: Ana Lala: Dude\"\n            let strings = results.data[0];\n            if (strings.length === 1) {\n                return; // find a way to handle message that wraps but does a new line first\n            }\n            let dateEnd = nthIndex(strings[1], \":\", 3);\n            let nameEnd = nthIndex(strings[1], \":\", 4);\n            if (nameEnd === -1) { // Auto-message: Messages you send to this chat and calls are now secured with end-to-end encryption.\n                return;\n            }\n            // 2017-01-09, 12:41:06 PM\n            let date = strings[0] + strings[1].substring(0, dateEnd);\n            let name = strings[1].substring(dateEnd + 2, nameEnd);\n            let message = strings[1].substring(nameEnd + 2, strings[1].length);\n            let m = {\n                date,\n                name,\n                message\n            };\n            messages.push(m);\n        },\n        complete: () => {\n            postMessage({type: \"done\", value: messages});\n        },\n        worker: true,\n        skipEmptyLines: true\n    });\n};\n//\n// const Parse = (file) => {\n//     let messages = [];\n//     Papa.parse(file, {\n//         newline: '\\r\\n',\n//         step: (results) => {\n//             // Example of results returned in an array\n//             // 0: \"2017-03-12\"\n//             // 1: \" 9:59:47 AM: Ana Lala: Dude\"\n//             let strings = results.data[0];\n//             if (strings.length === 1) {\n//                 return; // find a way to handle message that wraps but does a new line first\n//             }\n//             let dateEnd = nthIndex(strings[1], \":\", 3);\n//             let nameEnd = nthIndex(strings[1], \":\", 4);\n//             if (nameEnd === -1) { // Auto-message: Messages you send to this chat and calls are now secured with end-to-end encryption.\n//                 return;\n//             }\n//             // 2017-01-09, 12:41:06 PM\n//             let date = strings[0] + strings[1].substring(0, dateEnd);\n//             let name = strings[1].substring(dateEnd + 2, nameEnd);\n//             let message = strings[1].substring(nameEnd + 2, strings[1].length);\n//             let m = new Message(date, name, message);\n//             messages.push(m);\n//         },\n//         complete: () => {\n//             return messages;\n//         },\n//         worker: true,\n//         skipEmptyLines: true\n//     });\n// };\n//\n// export default Parse;\n\n\n\n// WEBPACK FOOTER //\n// ./src/parse.js","/*!\n\tPapa Parse\n\tv4.2.0\n\thttps://github.com/mholt/PapaParse\n*/\n(function(root, factory)\n{\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && module.exports)\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n}(this, function()\n{\n\t'use strict';\n\n\tvar global = (function () {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n        // When running tests none of the above have been defined\n        return {};\n\t})();\n\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\telse if (Papa.WORKERS_SUPPORTED)\n\t{\n\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\n\t\t// Check if the script was loaded synchronously\n\t\tif (!document.body)\n\t\t{\n\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\tLOADED_SYNC = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}, true);\n\t\t}\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\t_config.dynamicTyping = _config.dynamicTyping || false;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && typeof _input.read === 'function' && typeof _input.on === 'function')\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\tvar _output = '';\n\t\tvar _fields = [];\n\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (_input instanceof Array)\n\t\t{\n\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\treturn serialize(null, _input);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (_input.data instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow 'exception: Unable to serialize unrecognized input';\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t{\n\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t}\n\n\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._paused = false;\n\t\tthis._finished = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\treturn;\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._paused)\n\t\t\t\t\treturn;\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);\n\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t\telse\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t}\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState != 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t}\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(errorText);\n\t\t}\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n        \t\t\treturn -1;\n            \t\t}\n\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t}\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t}\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t}\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t}\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar string;\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tstring = s;\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t}\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t}\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t}\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error.message);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._finished = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;   // Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(typeof _config.delimiter === 'function')\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\t_paused = false;\n\t\t\tself.streamer.parseChunk(_input);\n\t\t};\n\n\t\tthis.aborted = function ()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\''+Papa.DefaultDelimiter+'\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t_results.data.splice(0, 1);\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif ((_config.dynamicTyping[field] || _config.dynamicTyping) === true)\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\treturn tryParseFloat(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTyping()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\treturn _results;\n\n\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = _results.data[i][j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\t\t\t\t_results.data[i] = row;\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline)\n\t\t{\n\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\n\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t{\n\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= preview.data.length;\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t{\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t}\n\t\t}\n\n\t\tfunction guessLineEndings(input)\n\t\t{\n\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction tryParseFloat(val)\n\t\t{\n\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\t_results.errors.push({\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg,\n\t\t\t\trow: row\n\t\t\t});\n\t\t}\n\t}\n\n\n\n\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar = config.quoteChar || '\"';\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow 'Comment character same as delimiter';\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow 'Input must be a string';\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = typeof step === 'function';\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tvar quoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tvar quoteSearch = input.indexOf(quoteChar, quoteSearch+1);\n\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\tif (input[quoteSearch+1] === quoteChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[quoteSearch+1] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [], errors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\tfunction getScriptPath()\n\t{\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t}\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\tthrow new Error(\n\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t);\n\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow 'Not implemented.';\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object')\n\t\t\treturn obj;\n\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/papaparse/papaparse.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}